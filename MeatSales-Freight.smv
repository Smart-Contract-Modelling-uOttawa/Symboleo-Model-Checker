MODULE Timer(start, _max_time_)
 DEFINE _time :=  expired1 ? _max_time_ : -1;
 VAR active1  : boolean;
     expired1 : boolean;
 ASSIGN
   init(active1) := start;
   next(active1) := (active1 | start) ? TRUE : active1;
   init(expired1) :=  active1 ? {TRUE,FALSE} : FALSE;
   next(expired1) :=  case
           active1 & !expired1 : {TRUE,FALSE};
           expired1           : TRUE;
           TRUE              : FALSE;
       esac;

MODULE Event(start, _max_time_)
 DEFINE _inactive := (state = inactive);
        _happened := (state = happened);
        _expired  := (state = expired);
 VAR triggered : boolean;
         timer : Timer(start & !_happened & !_expired, _max_time_);
         state : {inactive, active, happened, expired};
		 performer	: {"CBEEF", "COSTCO"};

 ASSIGN
	-- init(performer) := {PERFORMERS_DOMAIN};  -- Pick one non deterministically among the possible values.
	next(performer)	:= case
		state=active & start	: {"CBEEF", "COSTCO"};
		TRUE	 				: performer;
	esac;
 ASSIGN
  init(triggered) := FALSE;
  next(triggered) := (state=active & start) ? {FALSE,TRUE} : FALSE;
  init(state)     := inactive;
  next(state)     := case
    state=inactive & start                          : active;
    state=active & start & triggered &
                           timer._time<_max_time_   : happened;
    state=active & start & timer._time = _max_time_ : expired;
    TRUE                                            : state;
  esac;

--------------------------------------------------------------------------------------
-- 'name' is party name
-- 'removeL/R/P' releases liability, righHolder or performer position of a party
-- 'addL/R/P' adds liability, righHolder or performer position to a party
--------------------------------------------------------------------------------------
MODULE Party(norm, name, removeL, addL, removeR, addR, removeP, addP)
  DEFINE
	_name 			:= name;
	_norm			:= norm;
	_is_performer	:= p_state=P;
	_is_liable		:= l_state=L;
	_is_rightHolder	:= r_state=R;

  VAR
	l_state	: {Init, L};
	r_state	: {Init, R};
	p_state	: {Init, P};

  ASSIGN
	init(l_state) := Init;
	next(l_state)	:= case
		l_state=Init & addL	: L;
		l_state=L &removeL	: Init;
		TRUE				: l_state;
	esac;

  ASSIGN
	init(r_state) := Init;
	next(r_state)	:= case
		r_state=Init & addR	: R;
		r_state=R & removeR : Init;
		TRUE				: r_state;
	esac;

  ASSIGN
	init(p_state) := Init;
	next(p_state)	:= case
		p_state=Init & addP : P;
		p_state=P & removeP	: Init;
		TRUE				: p_state;
	esac;

  INVAR
	!(addL & removeL) &
	!(addR & removeR) &
	!(addP & removeP) &
	!(_is_rightHolder & _is_liable);
	
--------------------------------------------------------------------------------------
-- 'cnt_in_effect'    indicates if the contract is in inEffect state
-- 'power_suspended'  indicates if a power suspends the obligation
-- 'cnt_suspended'    indicates if the contract suspension suspends the obligation
-- 'power_resumed'    indicates if a power resumption resumes the obligation
-- 'cnt_resumed'      indicates if the contract resumption resumes the obligation
--------------------------------------------------------------------------------------
MODULE Obligation(surviving, cnt_in_effect, cnt_untermination,
                  fulfilled, triggered, violated, activated,
				  expired1, power_suspended, cnt_suspended, terminated, power_resumed,
				  cnt_resumed, discharged, antecedent)
  DEFINE
	_surviving	:= surviving;
	_suspended 	:= (power_suspended | (cnt_suspended & !surviving));
	_active 	:= (state = inEffect | state = suspension);

  VAR
	state 		: {not_created, create, inEffect, suspension, discharge,
				   fulfillment, violation, unsTermination};
	sus_state	: {not_suspended, sus_by_contract, sus_by_power};

  ASSIGN
 --NEW: update axioms(surviving obligations are not suspended! informally mentioned)
	init(sus_state) := not_suspended;
	next(sus_state)	:= case
		sus_state=not_suspended & !surviving & cnt_suspended 	: sus_by_contract;
		sus_state=sus_by_contract & !surviving & cnt_resumed	: not_suspended;
		sus_state=not_suspended & !surviving & power_suspended 	: sus_by_power;
		sus_state=sus_by_power & !surviving & power_resumed		: not_suspended;
		TRUE													: sus_state;
	esac;

  ASSIGN
    init(state) := not_created;
    next(state) := case
		cnt_in_effect & state=not_created   & triggered & !antecedent : create;
		cnt_in_effect & state=not_created   & triggered & antecedent  : inEffect;
		cnt_in_effect & state=create        & antecedent              : inEffect;
		cnt_in_effect & state=create        & (expired1 | discharged)  : discharge;
		cnt_in_effect & state=inEffect      & fulfilled               : fulfillment;
		cnt_in_effect & state=inEffect      & _suspended              : suspension;
		cnt_in_effect & state=inEffect      & violated                : violation;
		cnt_in_effect & _active            	& terminated              : unsTermination;
		cnt_untermination & !surviving  	& _active           	  : unsTermination;
		sus_state=sus_by_contract & state=suspension  & cnt_resumed   : inEffect;
		sus_state=sus_by_power	  & state=suspension  & power_resumed   : inEffect;
		TRUE                                                          : state;
  esac;

--------------------------------------------------------------------------------------
-- 'cnt_in_effect'   indicates if the contract is in inEffect state
-- 'power_suspended' indicates if a power suspends the power
-- 'cnt_suspended'   indicates if the contract suspension suspends the power
-- 'power_resumed'   indicates if a power resumption resumes the power
-- 'cnt_resumed'     indicates if the contract resumption resumes the power
--------------------------------------------------------------------------------------
MODULE Power(cnt_in_effect, triggered, activated, expired1, power_suspended, cnt_suspended,
       	     terminated, exerted, power_resumed, cnt_resumed, antecedent)
  DEFINE
	_active 	 := (state = inEffect | state = suspension);
	_suspended 	 := (power_suspended | cnt_suspended);

  VAR
	state 		: {not_created, create, inEffect, suspension, sTermination, unsTermination};
	sus_state	: {not_suspended, sus_by_contract, sus_by_power};

  ASSIGN
	init(sus_state) := not_suspended;
	next(sus_state)	:= case
		sus_state=not_suspended & cnt_suspended 	: sus_by_contract;
		sus_state=sus_by_contract & cnt_resumed		: not_suspended;
		sus_state=not_suspended & power_suspended 	: sus_by_power;
		sus_state=sus_by_power & power_resumed		: not_suspended;
		TRUE										: sus_state;
	esac;

  ASSIGN
   init(state) := not_created;
   next(state) := case
     cnt_in_effect & state = not_created 	& triggered & !antecedent : create;
     cnt_in_effect & state = not_created 	& triggered & antecedent  : inEffect;
     cnt_in_effect & state = create      	& antecedent              : inEffect;
     cnt_in_effect & state = create      	& expired1                : unsTermination;
     cnt_in_effect & state = inEffect    	& exerted                 : sTermination;
     cnt_in_effect & state = inEffect   	& _suspended              : suspension;
     cnt_in_effect & state = inEffect    	& expired1                : unsTermination;
	 cnt_in_effect & _active  			 	& terminated              : unsTermination;

	 sus_state=sus_by_contract & state=suspension  & cnt_resumed 	  : inEffect;
	 sus_state=sus_by_power	   & state=suspension  & power_resumed      : inEffect;

     TRUE                                          				   	  : state;
   esac;

--------------------------------------------------------------------------------------
-- 'assigned_party'				 indicates if a party is assigned to a role
-- 'revoked_party'				 indicates if a party is unassigned from a role
-- 'fulfilled_active_obligation' indicates if all active obligations are fulfilled
--------------------------------------------------------------------------------------
MODULE Contract(triggered, activated, terminated, suspended, resumed,
				revoked_party, assigned_party, fulfilled_active_obligation)
  DEFINE
	_active 	 := (state = unassign | state = inEffect | state = suspension);
	_termination := (state = sTermination | state = unsTermination);

	-- obligations/powers' status changes once the contract goes to inEffect state
	_o_activated := (state = form & activated) |
						(state = suspension & resumed) |
						(state = unassign & assigned_party) |
						(state = inEffect);

  VAR
	state 		 : { not_created, form, inEffect, suspension, unassign, sTermination, unsTermination};

  ASSIGN
    init(state) := not_created;
    next(state) := case
		state = not_created & triggered  					: form;
		state = form        & activated  					: inEffect;
		state = inEffect    & fulfilled_active_obligation  	: sTermination;
		state = inEffect    & suspended  					: suspension;
		state = inEffect    & revoked_party  				: unassign;
		state = inEffect    & terminated 					: unsTermination;
		state = suspension  & resumed    					: inEffect;
		state = suspension  & terminated 					: unsTermination;
		state = unassign    & assigned_party 				: inEffect;
		state = unassign    & terminated 					: unsTermination;
		TRUE                             					: state;
    esac;

--------------------------------------------------------------------------------------
-- Domain Concepts
--------------------------------------------------------------------------------------
MODULE Asset(owner)
	DEFINE _owner := owner;
	
--------------------------------------------------------------------------------------
-- Decleration
--------------------------------------------------------------------------------------
MODULE PerishableGood(owner, qnt, qlt)	
	DEFINE
		quantity := qnt;
		quality := qlt;
	VAR
		asset : Asset(owner);
		
MODULE Delivered(start, max_time, item, deliveryAddress, delDueD)
	DEFINE
		_item := item;
		_deliveryAddress := deliveryAddress;
		_delDueD := delDueD;
	VAR
		event : Event(start, max_time);
		
MODULE Paid(start, max_time, amount, currency, from, to, payDueD)
	DEFINE
		_amount := amount;
		_currency := currency;
		_from := from;
		_to := to;
		_payDueD := payDueD;
	VAR
		event : Event(start, max_time);
		
MODULE PaidLate(start, max_time, amount, currency, from, to)
	DEFINE
		_amount := amount;
		_currency := currency;
		_from := from;
		_to := to;
	VAR
		event : Event(start, max_time);
		
MODULE Disclosed(start, max_time, contractID)
	DEFINE
		_contractID := contractID;
	VAR
		event : Event(start, max_time);

--------------------------------------------------------------------------------------
-- Sales of Goods contract
--------------------------------------------------------------------------------------
MODULE MeatSales_Contract(cnt_id, buyer, seller, qnt, qlt, amt, curr, pay_due_date, delAdd, effDate, del_due_days, intRate, carrier_delivered)
  CONSTANTS
	"Odel", "Opay",  "OlatePay", "SoBuyerDisclosure", "SoSellerDisclosure", "PsusDel", "PdelAssign", "PresumDel", "PterCnt", "goods";
  DEFINE
	PsusDel_exerted	 	:= PsusDel._active & suspended_delivery._happened & suspended_delivery.performer=PsusDel_creditor._name
						& PsusDel_creditor._is_performer;
	PresumDel_exerted	:= PresumDel._active & resumed_delivery._happened & resumed_delivery.performer=PresDel_creditor._name
						& PresDel_creditor._is_performer;
	PterCnt_exerted	 	:= PterCnt._active & terminated_C._happened & terminated_C.performer=PterCnt_creditor._name
						& PterCnt_creditor._is_performer;
	sCTerminated 		:= (C.state=inEffect) & !(Odel._active) & !(Opay._active) & !(OlatePay._active);

	PdelAssign_exerted	:= PdelAssign._active & sellerAssignedDel._happened & sellerAssignedDel.performer=PdelAsg_creditor._name
						& PdelAsg_creditor._is_performer;
	Opay_violated		:= paid.event._expired | (paid.event._happened & !(paid.event.performer = Opay_debtor._name
						& Opay_debtor._is_performer));
	paid_performer		:= (paid.event._happened &
						paid.event.performer = Opay_debtor._name & Opay_debtor._is_performer);
	delivered_performer	:= (delivered.event._happened &
						delivered.event.performer = Odel_debtor._name & Odel_debtor._is_performer);
	Odel_violated		:= delivered.event._expired | (delivered.event._happened &
						!(delivered.event.performer = Odel_debtor._name & Odel_debtor._is_performer));
	paidlate_performer  := (paidLate.event._happened & paidLate.event.performer = Olpay_debtor._name &
						Olpay_debtor._is_performer);
	PsubCnt_exerted	 	:= subcontracted._happened;	

  VAR	
	goods				: PerishableGood(seller, qnt, qlt);
	--* problem: cannot pass goods to the parameter of delivered
	delivered			: Delivered(Odel.state=inEffect, del_due_days, "goods", delAdd, del_due_days);						
	paid      			: Paid(Opay.state=inEffect, pay_due_date, amt, curr, buyer, seller, pay_due_date);
	paidLate			: PaidLate(OlatePay.state=inEffect, 2, amt, curr, buyer, seller);
	buyerDisclosed 		: Disclosed(C._active, 5, cnt_id);
	sellerDisclosed 	: Disclosed(C._active, 5, cnt_id);

	suspended_delivery 	: Event(PsusDel.state = inEffect, 2);	
	resumed_delivery   	: Event(PresumDel.state = inEffect, 2);	
	
	terminated_C   		: Event(PterCnt.state = inEffect, 4);	
	sellerAssignedDel  	: Event(PdelAssign.state = inEffect, 4);
	
	subcontracted   	: Event(PsubCnt.state = inEffect, 10);

	C 		 : Contract(TRUE, TRUE, PterCnt_exerted, FALSE, FALSE, FALSE, FALSE, sCTerminated);

	Odel 	 : Obligation(FALSE, C._o_activated, PterCnt_exerted,
                  (delivered.event._happened & delivered.event.performer = Odel_debtor._name & Odel_debtor._is_performer) | carrier_delivered,
                  TRUE, Odel_violated, FALSE, FALSE, PsusDel_exerted, FALSE, FALSE, PresumDel_exerted, FALSE, FALSE, TRUE);

	Opay 	 : Obligation(FALSE, C._o_activated, PterCnt_exerted, paid_performer, TRUE, Opay_violated, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, TRUE);

	OlatePay : Obligation(FALSE, C._o_activated, PterCnt_exerted,
                  paidlate_performer, Opay_violated, paidLate.event._expired, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, TRUE);

	SoBuyerDisclosure : Obligation(TRUE, C._o_activated, PterCnt_exerted,
                  buyerDisclosed.event._expired, TRUE, (buyerDisclosed.event._happened & buyerDisclosed.event.performer = BuyDis_debtor._name & BuyDis_debtor._is_performer), FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, TRUE);

	SoSellerDisclosure : Obligation(TRUE, C._o_activated, PterCnt_exerted,
                  sellerDisclosed.event._expired , TRUE, (sellerDisclosed.event._happened & sellerDisclosed.event.performer = SellDis_debtor._name & SellDis_debtor._is_performer),
				  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, TRUE);

	PsusDel  : Power(C._o_activated, Opay_violated, FALSE, FALSE, FALSE,
			   FALSE, FALSE, PsusDel_exerted, FALSE, FALSE, TRUE);

	PresumDel: Power(C._o_activated, paidlate_performer, FALSE, FALSE, FALSE, FALSE, FALSE, PresumDel_exerted, FALSE, FALSE, TRUE);
			 
	PterCnt  : Power(C._o_activated, Odel_violated, FALSE, FALSE, FALSE,
			   FALSE, FALSE, PterCnt_exerted, FALSE, FALSE, TRUE);

	PdelAssign  : Power(C._o_activated, TRUE, FALSE, FALSE, FALSE,
			   FALSE, FALSE, PdelAssign_exerted, FALSE, FALSE, TRUE);
			   
	PsubCnt  : Power(C._o_activated, TRUE, FALSE, FALSE, FALSE,
				   FALSE, FALSE, PsubCnt_exerted, FALSE, FALSE, TRUE);

	Odel_debtor   	: Party("Odel", seller, FALSE, TRUE, FALSE, FALSE, FALSE, TRUE);
	Odel_creditor 	: Party("Odel", buyer, FALSE, FALSE, FALSE, TRUE, FALSE, FALSE);
	SellDis_debtor	: Party("SoSellerDisclosure", seller, FALSE, TRUE, FALSE, FALSE, FALSE, TRUE);
	SellDis_creditor: Party("SoSellerDisclosure", buyer, FALSE, FALSE, FALSE, TRUE, FALSE, FALSE);


	Opay_debtor   	: Party("Opay", buyer, FALSE, TRUE, FALSE, FALSE, FALSE, TRUE);
	Opay_creditor   : Party("Opay", seller, FALSE, FALSE, FALSE, TRUE, FALSE, FALSE);
	Olpay_debtor   	: Party("OlatePay", buyer, FALSE, TRUE, FALSE, FALSE, FALSE, TRUE);
	Olpay_creditor  : Party("OlatePay", seller, FALSE, FALSE, FALSE, TRUE, FALSE, FALSE);
	BuyDis_debtor   : Party("SoBuyerDisclosure", buyer, FALSE, TRUE, FALSE, FALSE, FALSE, TRUE);
	BuyDis_creditor	: Party("SoBuyerDisclosure", seller, FALSE, FALSE, FALSE, TRUE, FALSE, FALSE);

	PsusDel_debtor  : Party("PsusDel", buyer, FALSE, TRUE, FALSE, FALSE, FALSE, TRUE);
	PsusDel_creditor: Party("PsusDel", seller, FALSE, FALSE, FALSE, TRUE, FALSE, FALSE);
	PdelAsg_debtor  : Party("PdelAssign", buyer, FALSE, TRUE, FALSE, FALSE, FALSE, TRUE);
	PdelAsg_creditor: Party("PdelAssign", seller, FALSE, FALSE, FALSE, TRUE, FALSE, FALSE);

	PresDel_debtor  : Party("PresumDel", seller, FALSE, TRUE, FALSE, FALSE, FALSE, TRUE);
	PresDel_creditor: Party("PresumDel", buyer, FALSE, FALSE, FALSE, TRUE, FALSE, FALSE);
	PterCnt_debtor  : Party("PterCnt", seller, FALSE, TRUE, FALSE, FALSE, FALSE, TRUE);
	PterCnt_creditor: Party("PterCnt", buyer, FALSE, FALSE, FALSE, TRUE, FALSE, FALSE);

  INVAR
	buyer != seller;

--------------------------------------------------------------------------------------
-- Freight contract
--------------------------------------------------------------------------------------
MODULE Freight_Contract(shipper, carrier, triggered, pay_due_date, del_due_days)
  CONSTANTS
		"OfrDel", "OfrPay", "OfrLatePay";
  DEFINE 
		sCTerminated 	:= !(OfrDel._active) & !(OfrPay._active) & !(OfrLatePay._active);
		OfrPay_violated	:= frPaid._expired;

  VAR 
		frDelivered 	: Event(OfrDel.state=inEffect, del_due_days);
		frPaid      	: Event(OfrPay.state=inEffect, pay_due_date);
		frPaidLate     	: Event(OfrLatePay.state=inEffect, 10);

		C : Contract(triggered, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, sCTerminated);

		OfrDel 	  : Obligation(FALSE, C._o_activated, FALSE,
                 frDelivered._happened & frDelivered.performer = Odel_debtor._name & Odel_debtor._is_performer, TRUE, frDelivered._expired,
                 FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, TRUE);			
		
		OfrPay 	  : Obligation(FALSE, C._o_activated, FALSE,
                 frPaid._happened & frPaid.performer = Opay_debtor._name & Opay_debtor._is_performer, frDelivered._happened & frDelivered.performer = Odel_debtor._name & Odel_debtor._is_performer,
				 frPaid._expired, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, TRUE);
		
		OfrLatePay : Obligation(FALSE, C._o_activated, FALSE,
                 frPaidLate._happened & frPaidLate.performer = Olpay_debtor._name & Olpay_debtor._is_performer, OfrPay_violated, frPaidLate._expired,
                 FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, TRUE);
		
		Odel_debtor   	: Party("OfrDel", carrier, FALSE, TRUE, FALSE, FALSE, FALSE, TRUE);
		Odel_creditor 	: Party("OfrDel", shipper, FALSE, FALSE, FALSE, TRUE, FALSE, FALSE);
		
		Opay_debtor   	: Party("OfrPay", shipper, FALSE, TRUE, FALSE, FALSE, FALSE, TRUE);
		Opay_creditor 	: Party("OfrPay", carrier, FALSE, FALSE, FALSE, TRUE, FALSE, FALSE);
		
		Olpay_debtor   	: Party("OfrLatePay", shipper, FALSE, TRUE, FALSE, FALSE, FALSE, TRUE);
		Olpay_creditor 	: Party("OfrLatePay", carrier, FALSE, FALSE, FALSE, TRUE, FALSE, FALSE);

MODULE main
  CONSTANTS
	"CBEEF", "COSTCO", "FedEx", "Correo", "CPost", "good", "cad", "nov21", "ottawa", "id123";
	
  VAR
	sales_cnt 				: MeatSales_Contract("id123", "COSTCO", "CBEEF", 4, "good", 1000, "cad", 4, "ottawa", "nov21", 4, 10, (argToPortFreight_cnt.C.state=sTermination & portToCanFreight_cnt.C.state=sTermination & canToBuyerFreight_cnt.C.state=sTermination));
	
	argToPortFreight_cnt	: Freight_Contract(sales_cnt.seller, "Correo", sales_cnt.PsubCnt_exerted, 3, 5);
	
	portToCanFreight_cnt	: Freight_Contract(sales_cnt.seller, "FedEx", sales_cnt.PsubCnt_exerted & argToPortFreight_cnt.OfrDel.state=fulfillment, 3, 5);
	
	canToBuyerFreight_cnt : Freight_Contract(sales_cnt.seller, "CPost", sales_cnt.PsubCnt_exerted & portToCanFreight_cnt.OfrDel.state=fulfillment, 3, 5);
	
	--* subcontract
	Odel_subcontractor : Party("Odel", "FedEx", FALSE, FALSE, FALSE, FALSE, canToBuyerFreight_cnt.C.state=sTermination, sales_cnt.PresumDel_exerted);
	
	
  ASSIGN
	--* Number	   : 3.1
	--* Description: (versus 1.2)a sales delivery is never violated after successful termination 
	--*				 of freight contract
	--* Type 	   : undesirable property
	--* Pattern	   : Absence pattern #13
	--* Fails	   : if buyer does not pay and consequently seller suspends delivery obligation, 
	--*			     then successful termination of freight contract cannot fullfill delivery obligation	
	LTLSPEC G(canToBuyerFreight_cnt.C.state = sTermination -> G !sales_cnt.Odel_violated)
		
	--* Number	   : 3.2
	--* Description: a freight subcontract is never active after termination of sales contract
	--* Type 	   : undesirable property
	--* Pattern	   : Absence pattern #13
	--* Fails	   : there is no freight termination power. Then, state of sales contract does 
	--*				 not influence state of an active freight subcontract
	LTLSPEC G(sales_cnt.C.state = sTermination | sales_cnt.C.state = unsTermination 
				-> G !canToBuyerFreight_cnt.C._active)
		
	------------------------------------------------------------------------------------
	-- Runtime verification
	------------------------------------------------------------------------------------
	--* Number	   : 5.0
	--* Description: under the mentioned state(payment done, delivery is going on), a freight contract 
	--*				 may fulfills delivery obligation in future
	--* Type	   : desirable property
	--* Intention  : seller
	 CTLSPEC AF(sales_cnt.C.state=inEffect &
			  sales_cnt.Odel.state=inEffect &
			  sales_cnt.Opay.state=fulfillment &
			  sales_cnt.OlatePay.state=not_created &
			  sales_cnt.PsusDel.state=not_created &
			  sales_cnt.PresumDel.state=not_created &
			  sales_cnt.PterCnt.state=not_created &
			  !sales_cnt.PsubCnt_exerted &
			  canToBuyerFreight_cnt.C.state=not_created
			  ->  AX (canToBuyerFreight_cnt.C.state=form 
						-> EF (canToBuyerFreight_cnt.C.state=sTermination -> AX 	
							sales_cnt.Odel.state=fulfillment)
					)
				)
		
	--* Pattern	   : pattern #4 and #5
	CTLSPEC AG(sales_cnt.C.state=inEffect &
		  sales_cnt.Odel.state=inEffect &
		  sales_cnt.Opay.state=fulfillment &
		  sales_cnt.OlatePay.state=not_created &
		  sales_cnt.PsusDel.state=not_created &
		  sales_cnt.PresumDel.state=not_created &
		  sales_cnt.PterCnt.state=not_created &
		  !sales_cnt.PsubCnt_exerted &
		  canToBuyerFreight_cnt.C.state=not_created
		  -> AF(
				AG(canToBuyerFreight_cnt.C.state=form 
						-> EF (canToBuyerFreight_cnt.C.state=sTermination -> AX 
							sales_cnt.Odel.state=fulfillment)
					)
				)
			)